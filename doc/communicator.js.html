<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Source: communicator.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body data-theme="light"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">Home</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-modules"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-Communicator.html">Communicator</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-classes"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Communicator.html">Communicator</a></div><div class="sidebar-section-children"><a href="Message.html">Message</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#dark-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">communicator.js</h1></header><article><pre class="prettyprint source lang-js"><code>"use strict";

/**
 * Creates a new Person.
 * @class
 */
const Message = class {
    //for inner usage
    packetSize;
    packetTimeout;
    packetRetry;
    sendThreads;

    onreceive = function() {};
    packetCallbacks = new Map();
    onaborts = new Set();
    onFinish = function() {};

    messageId;
    timeoutId = -1;
    interactTimeoutId = -1;
    isAnswer = false;
    answerFor = 0;
    packetCount = Infinity;
    packets = new Map();
    process;

    constructor() {

    };

    //
    //public API methods
    //
    //events
    onprogress = function(message) {};

    //methods
    progress = 0;
    error = "";
    data;
    isInvoke = false;
    send = undefined;
    invoke = undefined;
    abort() {
        this.error = "abort";
        for (const cb of this.onaborts) {
            cb();
        }
    };
    async wait() {
        return this.process;
    };
};

/**
 * Creates a new Person.
 * @class
 */
const Communicator = class {
    UID = 1; //random positive number to decide the side
    sender = async function(data, transfer) {}; //sender function
    interactTimeout = 5000; //cancel if not happen any transmission in time

    timeout = 5000; //the whole invoke process time limit
    packetSize = 16384; //max size of each packet
    packetTimeout = 1000; //timeout for packet acknowledgment
    packetRetry = Infinity; //retry attemts number for one packets
    sendThreads = 16; //packets that can be sent in same time

    timeOffset = 0;
    timeSyncIntervalId = -1;
    timePromise;
    timeResolve;

    sidePromise;
    sideResolve;

    messageId = 0;
    myReminder = 0;
    messages = new Map();

    ERROR_TIMEOUT = "timeout"; // when run out of the time
    ERROR_INACTIVE = "inactive"; // when no answer for long time
    ERROR_ABORT = "abort"; // local abort
    ERROR_REJECT = "reject"; // remote abort
    ERROR_TRANSFER_SEND = "send"; // cannot send
    ERROR_TRANSFER_RECEIVE = "receive"; // answer not arrived

    onincoming = function(message) {};
    onsend = function(data) {};
    oninvoke = function(message) {};

    

    // methods: send, invoke, receive,
    // events: onincoming, onsend, oninvoke
    // methods (process):  abort, wait, send, invoke
    // events (process):  progress
    constructor(config) {
        this.configure(config);
    };
    configure(config) {
        //set variables
        if (typeof config !== "object") {
            throw new Error("Configuration needs to be an object.");
        }

        //set required params and static params
        if (typeof config["sender"] !== "undefined") {
            if (typeof config["sender"] === "function") {
                this.sender = config["sender"];
            } else {
                throw new Error("'sender' option must be function");
            }
        }

        //set optional and static params
        if (typeof config["interactTimeout"] !== "undefined") {
            if (typeof config["interactTimeout"] === "number") {
                this.interactTimeout = config["interactTimeout"];
            } else {
                throw new Error("'interactTimeout' option must be number");
            }
        }

        //set optional params
        if (typeof config["timeout"] !== "undefined") {
            if (typeof config["timeout"] === "number") {
                this.timeout = config["timeout"];
            } else {
                throw new Error("'timeout' option must be number");
            }
        }
        if (typeof config["packetSize"] !== "undefined") {
            if (typeof config["packetSize"] === "number") {
                this.packetSize = config["packetSize"];
            } else {
                throw new Error("'packetSize' option must be number");
            }
        }
        if (typeof config["packetTimeout"] !== "undefined") {
            if (typeof config["packetTimeout"] === "number") {
                this.packetTimeout = config["packetTimeout"];
            } else {
                throw new Error("'packetRetry' option must be number");
            }
        }
        if (typeof config["packetRetry"] !== "undefined") {
            if (typeof config["packetRetry"] === "number") {
                this.packetRetry = config["packetRetry"];
            } else {
                throw new Error("'packetRetry' option must be number");
            }
        }
        if (typeof config["sendThreads"] !== "undefined") {
            if (typeof config["sendThreads"] === "number") {
                this.sendThreads = config["sendThreads"];
            } else {
                throw new Error("'sendThreads' option must be number");
            }
        }

        //initial setup
        this.UID = Math.floor(Math.random() * 4294967294) + 1; // betwwen 1 and (32 bit-1)
    };
    release() {
        //free up every pointer that point to non internal variables
        this.sender = async function(data, transfer) {};
        this.messages = new Map();
    };


    TimeSyncStart(resyncTime = 60000) {
        this.TimeSyncStop();
        this.SyncTime();
        this.timeSyncIntervalId = setInterval(() => {
            this.SyncTime();
        }, resyncTime);
    };
    TimeSyncStop() {
        clearInterval(this.timeSyncIntervalId);
    };
    async TimeSync(retry = 5, patience = this.interactTimeout) {
        //check runnig request
        if (this.timePromise !== undefined) {
            return this.timePromise;
        }

        //start request
        this.timePromise = this.TimeSyncRaw(retry, patience);
        const isSuccess = await this.timePromise;
        this.timePromise = undefined;
        return isSuccess;
    };
    async TimeSyncRaw(retry, patience) {
        let isSuccess = false;
        let trying = 0;
        do {
            trying++;

            isSuccess = await new Promise((resolve) => {
                this.TimeSyncResolve(resolve, patience);

                //send
                const buffer = new ArrayBuffer(17);
                const view = new DataView(buffer);
                view.setUint8(view.byteLength - 1, 1); //time sync flag
                view.setFloat64(view.byteLength - 9, Date.now()); //my time
                view.setFloat64(view.byteLength - 17, -1); //other time
                this.sender(buffer, [buffer]);
            });
        } while (trying &lt; retry &amp;&amp; isSuccess === false);

        if (isSuccess === false) {
            isSuccess = await new Promise((resolve) => {
                this.TimeSyncResolve(resolve, this.interactTimeout);
            });
        }

        return isSuccess;
    };
    TimeSyncResolve(resolve, patience) {
        //timeout
        const timeout = setTimeout(() => {
            this.timeResolve = undefined;
            resolve(false);
        }, patience);

        //callback
        this.timeResolve = () => {
            this.timeResolve = undefined;
            clearTimeout(timeout);
            resolve(true);
        };
    };

    async SideSync(retry = 5, patience = this.interactTimeout) {
        //check runnig request
        if (this.sidePromise !== undefined) {
            return this.sidePromise;
        }

        //start request
        this.sidePromise = this.SideSyncRaw(retry, patience);
        const isSuccess = await this.sidePromise;
        this.sidePromise = undefined;
        return isSuccess;
    };
    async SideSyncRaw(retry, patience) {
        let isSuccess = false;
        let trying = 0;
        do {
            trying++;
            isSuccess = await new Promise((resolve) => {
                this.SideSyncResolve(resolve, patience);

                //send
                const buffer = new ArrayBuffer(13);
                const view = new DataView(buffer);
                view.setUint8(view.byteLength - 1, 2); //side sync flag
                view.setUint32(view.byteLength - 5, Date.now() % 4294967295); //my time
                view.setUint32(view.byteLength - 9, this.UID); //my UID
                view.setUint32(view.byteLength - 13, 0); //other UID
                this.sender(buffer, [buffer]);
            });
        } while (trying &lt; retry &amp;&amp; isSuccess === false);

        if (isSuccess === false) {
            isSuccess = await new Promise((resolve) => {
                this.SideSyncResolve(resolve, this.interactTimeout);
            });
        }

        return isSuccess;
    };
    SideSyncResolve(resolve, patience) {
        //timeout
        const timeout = setTimeout(() => {
            this.sideResolve = undefined;
            resolve(false);
        }, patience);

        //callback
        this.sideResolve = (otherUID) => {
            this.sideResolve = undefined;
            clearTimeout(timeout);

            if (otherUID === this.UID) {
                //console.log("UID", this.UID, otherUID);
                this.UID = Math.floor(Math.random() * 4294967294) + 1; // betwwen 1 and (32 bit-1)
                resolve(false);
            } else {
                //console.log("UID", this.UID, otherUID);
                this.myReminder = (this.UID > otherUID ? 1 : 0);
                this.messageId = this.myReminder;
                resolve(true);
            }

        };
    };


    send(msg, transfer = [], timeout, options) {
        //create
        const messageObj = this.MessageCreate();

        //set params
        this.MessageSet(messageObj, options, false);

        //create pending process
        messageObj.process = this.sendRaw(messageObj, msg, transfer, timeout);

        return messageObj;
    };
    async sendRaw(messageObj, msg, transfer, timeout) {
        //prevent recalling
        messageObj.send = undefined;
        messageObj.invoke = undefined;

        //timeout abort
        if (typeof timeout !== "number") {
            timeout = this.timeout;
        }
        messageObj.timeoutId = setTimeout(() => {
            messageObj.error = this.ERROR_TIMEOUT;
            for (const cb of messageObj.onaborts) {
                cb();
            }
        }, timeout);

        //send data
        await this.MessageSend(messageObj, msg, transfer);
        this.MessageFree(messageObj);

        return messageObj;
    };
    invoke(msg, transfer = [], timeout, options) {
        //create
        const messageObj = this.MessageCreate();

        //set params
        this.MessageSet(messageObj, options, true);

        //create pending process
        messageObj.process = this.invokeRaw(messageObj, msg, transfer, timeout);

        return messageObj;
    };
    async invokeRaw(messageObj, msg, transfer, timeout) {
        return new Promise((resolve) => {
            //prevent recalling
            messageObj.send = undefined;
            messageObj.invoke = undefined;

            //timeout abort
            if (typeof timeout !== "number") {
                timeout = this.timeout;
            }
            messageObj.timeoutId = setTimeout(() => {
                messageObj.error = this.ERROR_TIMEOUT;
                for (const cb of messageObj.onaborts) {
                    cb();
                }
            }, timeout);

            //exit if error
            messageObj.onaborts.add(() => {
                console.log("aborted");
                console.log(messageObj.error);
                this.MessageFree(messageObj);
                resolve([messageObj.error, messageObj.data, messageObj.isInvoke]);
            });

            //or exit if invoke finish
            messageObj.onFinish = () => {
                this.MessageFree(messageObj);
                messageObj.send = (msg, transfer, timeout, options) => {
                    this.MessageSet(messageObj, options, false);
                    messageObj.process = this.sendRaw(messageObj, msg, transfer, timeout);
                };
                messageObj.invoke = (msg, transfer, timeout, options) => {
                    this.MessageSet(messageObj, options, true);
                    console.log("a");
                    messageObj.process = this.invokeRaw(messageObj, msg, transfer, timeout);
                };
                resolve([messageObj.error, messageObj.data, messageObj.isInvoke]);
            };

            //send data
            this.MessageSend(messageObj, msg, transfer);
        });
    }


    async receive(msg) {
        //1bit time sync request flag
        //1bit side sync request flag
        //1bit invoke flag
        //1bit split flag
        //1bit abort flag
        //1bit answer flag
        //2bit unused

        //my time - 64bit float timestamp (only time sync)
        //other time - 64bit float timestamp (only time sync)

        //my time - 32bit uint (only side sync)
        //my UID - 32bit uint (only side sync)
        //other UID - 32bit uint (only side sync)

        //32bit send time
        //32bit message id
        //16bit packet id (split)
        //16bit packet count (split, first)
        //32bit answer for (answer flag)

        //data...

        //mandaory header
        let isTimeSync = false;
        let isSideSync = false;
        let isInvoke = false;
        let isSplit = false;
        let isAbort = false;
        let isAnswer = false;

        //time header
        let time1 = 0;
        let time2 = 0;

        //side header
        let time = 0;
        let UID1 = 0;
        let UID2 = 0;

        //message header
        let sendTime = 0;
        let messageId = 0;
        let packetId = 0;
        let packetCount = 1;
        let answerFor = 0;

        //data
        let data;

        //read from different types
        if (msg instanceof Array &amp;&amp; msg.length > 1) {
            //handle 1st layer
            let offset = 0;
            const h = msg[offset++];
            isTimeSync = ((h &amp; 1) !== 0 ? true : false); //get time sync request
            isSideSync = ((h &amp; 2) !== 0 ? true : false); //get side sync request

            //handle 2nd layer
            if (isTimeSync) {
                time1 = msg[offset++];
                time2 = msg[offset++];

            } else if (isSideSync) {
                time = msg[offset++];
                UID1 = msg[offset++];
                UID2 = msg[offset++];

            } else {
                isInvoke = ((h &amp; 4) !== 0 ? true : false); //get invoke flag
                isSplit = ((h &amp; 8) !== 0 ? true : false); //get split flag
                isAbort = ((h &amp; 16) !== 0 ? true : false); //get abort flag
                isAnswer = ((h &amp; 32) !== 0 ? true : false); //get answer flag
                sendTime = msg[offset++]; //get send time
                messageId = msg[offset++]; //get message id
                if (isSplit) {
                    packetId = msg[offset++]; //get packet id
                    if (packetId === 0) {
                        packetCount = msg[offset++]; //get packet count
                    }
                }
                if (isAnswer) {
                    answerFor = msg[offset++]; //get answer for
                }
                data = msg[offset++]; //get data
            }

        } else if (msg instanceof ArrayBuffer &amp;&amp; msg.byteLength > 0) {
            //handle 1st layer
            let offset = 0;
            const view = new DataView(msg);
            offset += 1;
            let h = view.getUint8(msg.byteLength - offset);
            isTimeSync = ((h &amp; 1) !== 0 ? true : false); //get time sync request
            isSideSync = ((h &amp; 2) !== 0 ? true : false); //get side sync request

            //handle 2nd layer
            if (isTimeSync) {
                offset += 8;
                time1 = view.getFloat64(view.byteLength - offset);
                offset += 8;
                time2 = view.getFloat64(view.byteLength - offset);

            } else if (isSideSync) {
                offset += 4;
                time = view.getUint32(view.byteLength - offset);
                offset += 4;
                UID1 = view.getUint32(view.byteLength - offset);
                offset += 4;
                UID2 = view.getUint32(view.byteLength - offset);

            } else {
                isInvoke = ((h &amp; 4) !== 0 ? true : false); //get invoke flag
                isSplit = ((h &amp; 8) !== 0 ? true : false); //get split flag
                isAbort = ((h &amp; 16) !== 0 ? true : false); //get abort flag
                isAnswer = ((h &amp; 32) !== 0 ? true : false); //get answer flag

                offset += 4;
                sendTime = view.getUint32(view.byteLength - offset); //get send time
                offset += 4;
                messageId = view.getUint32(view.byteLength - offset); //get message id
                if (isSplit) {
                    offset += 2;
                    packetId = view.getUint16(view.byteLength - offset); //get packet id
                    if (packetId === 0 &amp;&amp; messageId % 2 !== this.myReminder) {
                        offset += 2;
                        packetCount = view.getUint16(view.byteLength - offset); //get packet count
                    }
                }
                if (isAnswer) {
                    offset += 4;
                    answerFor = view.getUint32(view.byteLength - offset); //get answer for
                }
                data = msg.transfer(msg.byteLength - offset); //get data


            }

        } else {
            console.warn("Wrong format incoming", msg);
            return;
        }

        // handle time sync packets
        if (isTimeSync) {
            //recive others request
            if (time2 === -1) {
                const buffer = new ArrayBuffer(25);
                const view = new DataView(buffer);
                view.setUint8(view.byteLength - 1, 1);
                view.setFloat64(view.byteLength - 9, time1);
                view.setFloat64(view.byteLength - 17, Date.now());
                this.sender(buffer, [buffer]);
                return;
            }

            //recive my request
            const returnTime = Date.now() - time1;
            if (returnTime > this.interactTimeout || this.timeResolve === undefined) {
                return;
            }
            const timeOffset = (time2 + (returnTime / 2)) - Date.now();
            //console.log(timeOffset);
            this.timeOffset = timeOffset;
            this.timeResolve();
            return;
        }

        // handle side sync packets
        if (isSideSync) {
            //recive others request
            if (UID2 === 0) {
                const buffer = new ArrayBuffer(25);
                const view = new DataView(buffer);
                view.setUint8(view.byteLength - 1, 2);
                view.setUint32(view.byteLength - 5, time);
                view.setUint32(view.byteLength - 9, UID1);
                view.setUint32(view.byteLength - 13, this.UID);
                this.sender(buffer, [buffer]);
                return;
            }

            //recive my request
            const now = Date.now() % 4294967295 - 100;
            if (time &lt; now || now - time > this.interactTimeout || UID1 !== this.UID) {
                return;
            }
            //console.log("uid", UID1, UID2);
            this.sideResolve(UID2);
            return;
        }

        // delete outdated packets
        const now = Date.now() % 4294967295 - 100;
        if (sendTime &lt; now || now - sendTime > this.interactTimeout) {
            return;
        }

        // my packets
        if (messageId % 2 === this.myReminder) {
            this.receiveMy(isAbort, messageId, packetId);
            return;
        }

        // other packets
        this.receiveOther(isInvoke, isSplit, isAbort, isAnswer, messageId, packetId, packetCount, answerFor, data);
    };
    async receiveMy(isAbort, messageId, packetId) {
        //get relevant object
        const messageObj = this.messages.get(messageId);

        //exit if not exist
        if (messageObj === undefined) {
            return;
        }

        //call the listening message
        messageObj.onreceive(isAbort, packetId);
        return;
    };
    async receiveOther(isInvoke, isSplit, isAbort, isAnswer, messageId, packetId, packetCount, answerFor, data) {
        // load message object
        let messageObj = this.messages.get(messageId);

        // solve if not exist
        if (messageObj === undefined) {
            if (isAnswer) {
                console.log(isAnswer);
                // check the parent object (and not moved yet)
                messageObj = this.messages.get(answerFor);

                // exit if no parent
                if (messageObj === undefined) {
                    return;
                }

                // move message object
                messageObj.messageId = messageId;
                messageObj.isInvoke = (isInvoke === 1 ? true : false);
                messageObj.isAnswer = true;
                messageObj.packets = new Map();
                this.messages.delete(answerFor);
                this.messages.set(messageId, messageObj);

                // todo: trigger incoming answer
                //trigger incoming event
                messageObj.onincoming?.(messageObj);

            } else {
                //create new object
                messageObj = new Message();
                messageObj.messageId = messageId;
                messageObj.isInvoke = isInvoke;
                this.messages.set(messageId, messageObj);

                //create wait function
                messageObj.process = new Promise((resolve) => {
                    messageObj.onaborts.add(() => {
                        resolve([messageObj.error, messageObj.data, messageObj.isInvoke]);
                    });

                    //or exit if invoke finish
                    messageObj.onFinish = () => {
                        resolve([messageObj.error, messageObj.data, messageObj.isInvoke]);
                    };
                });
                //trigger incoming event
                this.onincoming?.(messageObj);
            }
        }

        //refresh interactivity
        clearTimeout(messageObj.interactTimeoutId);
        messageObj.interactTimeoutId = setTimeout(() => {
            messageObj.error = this.ERROR_INACTIVE;
            for (const cb of messageObj.onaborts) {
                cb();
            }
            messageObj?.onFinish?.();
            this.MessageFree(messageObj);
        }, this.interactTimeout);

        //abort
        if (isAbort) {
            return;
        }

        //set data
        if (packetId === 0) {
            //first chunk
            messageObj.packetCount = packetCount;
        }
        messageObj.packets.set(packetId, data);
        //console.log(packetId, data);


        //send ack
        const sendTime = (Date.now() + this.timeOffset) % 4294967295; //32 bit time
        const ack = new ArrayBuffer(11);
        const view = new DataView(ack);
        view.setUint32(view.byteLength - 5, sendTime);
        view.setUint32(view.byteLength - 9, messageId);
        if (isSplit) {
            view.setUint8(view.byteLength - 1, (isSplit ? 8 : 0));
            view.setUint16(view.byteLength - 11, packetId);
        }
        this.sender(ack, [ack]);

        //check finish
        if (messageObj.packetCount === messageObj.packets.size) {
            const firstPacket = messageObj.packets.get(0);
            if (firstPacket instanceof ArrayBuffer) {
                //calc max message size
                let size = 0;
                const it = messageObj.packets[Symbol.iterator]();
                for (const [key, value] of it) {
                    size += value.byteLength;
                }
                const data = new Uint8Array(size);

                //copy packets data
                const it2 = messageObj.packets[Symbol.iterator]();
                let offset = 0;
                for (const [key, value] of it2) {
                    data.set(new Uint8Array(value), offset);
                    offset += value.byteLength;
                }
                messageObj.data = data.buffer;
            } else {
                messageObj.data = firstPacket;
            }
            //console.log(new Uint8Array(messageObj.data))
            //console.log(messageObj.isAnswer);

            //callback (if new)
            if (messageObj.isAnswer === false) {
                if (messageObj.isInvoke) {
                    messageObj.send = (msg, transfer, timeout = messageObj.timeout, options) => {

                        this.MessageSet(messageObj, options, false);
                        messageObj.process = this.sendRaw(messageObj, msg, transfer, timeout);
                    };
                    messageObj.invoke = (msg, transfer, timeout, options) => {
                        this.MessageSet(messageObj, options, true);
                        messageObj.process = this.invokeRaw(messageObj, msg, transfer, timeout);
                    };
                    this.oninvoke?.(messageObj);
                } else {
                    this.onsend?.(messageObj.data);
                }
            } else {
                //todo need answer triggering
                if (messageObj.isInvoke) {
                    messageObj.send = (msg, transfer, timeout = messageObj.timeout, options) => {
                        this.MessageSet(messageObj, options, false);
                        messageObj.process = this.sendRaw(messageObj, msg, transfer, timeout);
                    };
                    messageObj.invoke = (msg, transfer, timeout = messageObj.timeout, options) => {
                        this.MessageSet(messageObj, options, true);
                        messageObj.process = this.invokeRaw(messageObj, msg, transfer, timeout);
                    };
                    messageObj.oninvoke?.(messageObj);
                } else {
                    messageObj.onsend?.(messageObj.data);
                }
            }
            //callback
            messageObj?.onFinish?.();
            this.MessageFree(messageObj);
        }
    };


    MessageCreate() {
        //get unique message id
        do {
            this.messageId = (this.messageId + 2) % 4294967294; // 32 bit-1
        } while (this.messages.has(this.messageId));
        const messageId = this.messageId;

        //setup object on the global stack
        const messageObj = new Message();

        messageObj.messageId = messageId;
        this.messages.set(messageId, messageObj);
        return messageObj;
    };
    MessageSet(messageObj, options, isInvoke) {
        //set sending params
        let packetSize;
        let packetTimeout;
        let packetRetry;
        let sendThreads;
        if (typeof options === "object") {
            if ("packetSize" in options) {
                packetSize = options["packetSize"];
            }
            if ("packetTimeout" in options) {
                packetTimeout = options["packetTimeout"];
            }
            if ("packetRetry" in options) {
                packetRetry = options["packetRetry"];
            }
            if ("sendThreads" in options) {
                sendThreads = options["sendThreads"];
            }
        }
        if (packetSize === undefined) {
            packetSize = this.packetSize;
        }
        if (packetTimeout === undefined) {
            packetTimeout = this.packetTimeout;
        }
        if (packetRetry === undefined) {
            packetRetry = this.packetRetry;
        }
        if (sendThreads === undefined) {
            sendThreads = this.sendThreads;
        }
        messageObj.packetSize = packetSize;
        messageObj.packetTimeout = packetTimeout;
        messageObj.packetRetry = packetRetry;
        messageObj.sendThreads = sendThreads;

        //set invoke
        messageObj.isInvoke = isInvoke;

        //set answer (if need)
        if (messageObj.messageId % 2 !== this.myReminder) {
            messageObj.isAnswer = true;
            messageObj.answerFor = messageObj.messageId;
            //get unique message id
            do {
                this.messageId = (this.messageId + 2) % 4294967294; // 32 bit-1
            } while (this.messages.has(this.messageId));
            const messageId = this.messageId;

            this.messages.delete(messageObj.messageId);
            messageObj.messageId = messageId;
            this.messages.set(messageObj.messageId, messageObj);
        }
    };
    async MessageSend(messageObj, msg, transfer) {
        //initial interactivity
        const abort = () => {
            messageObj.error = this.ERROR_INACTIVE;
            for (const cb of messageObj.onaborts) {
                cb();
            }
        };
        clearTimeout(messageObj.interactTimeoutId);
        messageObj.interactTimeoutId = setTimeout(abort, this.interactTimeout);

        //message listener
        messageObj.onreceive = (isAbort, packetId) => {
            //update interactivity
            clearTimeout(messageObj.interactTimeoutId);
            messageObj.interactTimeoutId = setTimeout(abort, this.interactTimeout);

            //check abort
            if (isAbort) {
                messageObj.error = this.ERROR_REJECT;
                for (const cb of messageObj.onaborts) {
                    cb();
                }
                return;
            }

            //packet callback
            const cb = messageObj.packetCallbacks.get(packetId);
            cb?.();
        };

        //setup flags
        const invokeFlag = (messageObj.isInvoke ? 4 : 0);
        const answerFlag = (messageObj.isAnswer ? 32 : 0);

        //sending
        if (msg instanceof ArrayBuffer) {
            //general data
            const packetSize = messageObj.packetSize;
            const threadCount = messageObj.sendThreads;
            let generalOverhead = 9; // mandatory header size (every packet)
            const answerOverhead = (messageObj.isAnswer ? 4 : 0); // answer header size

            if (msg.byteLength + generalOverhead + answerOverhead &lt;= packetSize) {
                const data = new Uint8Array(msg.byteLength + generalOverhead + answerOverhead);
                //copy message
                data.set(new Uint8Array(msg.transfer()), 0);
                //set headers
                const view = new DataView(data.buffer);
                view.setUint8(view.byteLength - 1, invokeFlag + answerFlag);
                view.setUint32(view.byteLength - 9, messageObj.messageId);
                if (messageObj.isAnswer) {
                    view.setUint32(view.byteLength - 13, messageObj.answerFor);
                }
                //send
                await this.MessageSendPacket(messageObj, data.buffer, [data.buffer], 0);

            } else {
                //queue logic
                let stack = new Map();
                let stackId = 0;
                const next = async function(stackId, fn) {
                    stack.set(stackId, fn);
                    await fn;
                    stack.delete(stackId);
                };
                const race = async function() {
                    return new Promise((resolve, reject) => {
                        const it = stack[Symbol.iterator]();
                        for (const [key, value] of it) {
                            value.then(resolve, reject);
                        }
                    });
                };

                //modify general header size (because split)
                const splitFlag = 8;
                generalOverhead += 2;
                const firstOverhead = 2;

                //calculate slice count (2 byte first header, 9 byte packet header, 2 byte split header)
                //first calculation (without answer headers)
                let wholeSize = msg.byteLength + firstOverhead;
                let packetCount = Math.ceil(wholeSize / (packetSize - generalOverhead));
                //calculate answer flags count
                let answerCount = Math.min(threadCount, packetCount);
                //update size and packet count (only increase)
                wholeSize += answerCount * answerOverhead; //answer headers size 
                packetCount = Math.ceil(wholeSize / (packetSize - generalOverhead));
                answerCount = Math.min(threadCount, packetCount);

                let pos = 0;
                let size = packetSize - (generalOverhead + firstOverhead + answerOverhead)
                //first packet
                {
                    const data = new Uint8Array(packetSize);
                    //copy data
                    data.set(new Uint8Array(msg.slice(pos, pos + size)), 0);
                    pos += size;
                    //set headers
                    const view = new DataView(data.buffer);
                    view.setUint8(view.byteLength - 1, invokeFlag + answerFlag + splitFlag);
                    view.setUint32(view.byteLength - 9, messageObj.messageId);
                    view.setUint16(view.byteLength - 11, stackId);
                    view.setUint16(view.byteLength - 13, packetCount);
                    if (messageObj.isAnswer) {
                        view.setUint32(view.byteLength - 17, messageObj.answerFor);
                    }
                    //send
                    next(stackId, this.MessageSendPacket(messageObj, data.buffer, [data.buffer], stackId));
                    stackId++;
                }

                //initial packets (until sendThreads full)
                size = packetSize - (generalOverhead + answerOverhead);
                while (stackId &lt; answerCount &amp;&amp; messageObj.error === "") {
                    const data = new Uint8Array(Math.min(size, msg.byteLength - pos) + generalOverhead + answerOverhead);
                    //copy data
                    data.set(new Uint8Array(msg.slice(pos, pos + size)), 0);
                    pos += size;
                    //set headers
                    const view = new DataView(data.buffer);
                    view.setUint8(view.byteLength - 1, invokeFlag + answerFlag + splitFlag);
                    view.setUint32(view.byteLength - 9, messageObj.messageId);
                    view.setUint16(view.byteLength - 11, stackId);
                    if (messageObj.isAnswer) {
                        view.setUint32(view.byteLength - 15, messageObj.answerFor);
                    }
                    //send
                    next(stackId, this.MessageSendPacket(messageObj, data.buffer, [data.buffer], stackId));
                    stackId++;
                }
                await race();

                //other packets (wait for free thread)
                size = packetSize - generalOverhead;
                while (stackId &lt; packetCount &amp;&amp; messageObj.error === "") {
                    const data = new Uint8Array(Math.min(size, msg.byteLength - pos) + generalOverhead);
                    //copy data
                    data.set(new Uint8Array(msg.slice(pos, pos + size)), 0);
                    pos += size;
                    //set headers
                    const view = new DataView(data.buffer);
                    view.setUint8(view.byteLength - 1, invokeFlag + splitFlag);
                    view.setUint32(view.byteLength - 9, messageObj.messageId);
                    view.setUint16(view.byteLength - 11, stackId);
                    //send
                    next(stackId, this.MessageSendPacket(messageObj, data.buffer, [data.buffer], stackId));
                    stackId++;
                    await race();
                }

                //wait the reamining packets
                while (stack.size !== 0 &amp;&amp; messageObj.error === "") {
                    await race();
                }

            }
        } else {
            const data = [];
            //set headers
            data.push(invokeFlag + answerFlag);
            data.push(0);
            data.push(messageObj.messageId);
            if (messageObj.isAnswer) {
                data.push(messageObj.answerFor);
            }
            //copy message
            data.push(msg);
            //send
            await this.MessageSendPacket(messageObj, data, transfer, 0);
        }
    };
    async MessageSendPacket(messageObj, msg, transfer, packetId) {
        //params
        const retry = messageObj.packetRetry;
        const patience = messageObj.packetTimeout;
        //start sending
        let trying = 0;
        await new Promise((resolve) => {
            //free from memory
            const free = function() {
                clearTimeout(interval);
                messageObj.onaborts.delete(abort);
                messageObj.packetCallbacks.delete(packetId);
                resolve(undefined);
            };

            //success ack
            messageObj.packetCallbacks.set(packetId, () => {
                free();
            });

            //abort
            const abort = () => {
                free();
            };
            messageObj.onaborts.add(abort);

            //send
            const sending = () => {
                //abort if too much tries
                if (retry &lt; trying) {
                    messageObj.error = this.ERROR_TRANSFER_RECEIVE;
                    for (const cb of messageObj.onaborts) {
                        cb();
                    }
                    return;
                }

                //try send
                trying++;
                const sendTime = (Date.now() + this.timeOffset) % 4294967295; //32 bit time
                if (msg instanceof ArrayBuffer) {
                    const view = new DataView(msg);
                    view.setUint32(view.byteLength - 5, sendTime);
                    this.sender(msg, transfer);
                } else {
                    msg[1] = sendTime;
                    this.sender(msg, transfer);
                }
            };
            const interval = setInterval(sending, patience);
            sending();
        });
    };
    async MessageFree(messageObj) {
        //stop timers
        clearTimeout(messageObj.timeoutId);
        clearTimeout(messageObj.interactTimeoutId);

        //waiting stucked packets
        await new Promise((resolve) => {
            setTimeout(resolve, this.interactTimeout);
        });

        //free from global stack
        this.messages.delete(messageObj.messageId);
    };


};

/**
 * module description
 * @module Communicator
 */
export { Communicator };</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">Home</a><div class="mobile-nav-links"></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-modules"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-Communicator.html">Communicator</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-classes"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Communicator.html">Communicator</a></div><div class="sidebar-section-children"><a href="Message.html">Message</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#dark-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>